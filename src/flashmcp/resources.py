"""Resource management for FlashMCP."""

import abc
import asyncio
import json
import logging
import warnings
from pathlib import Path
from typing import Dict, Optional, Callable, Any
from urllib.parse import parse_qs, urlparse

import httpx
from pydantic import BaseModel, field_validator

logger = logging.getLogger("mcp")


class Resource(BaseModel):
    """Base class for all resources."""

    uri: str
    name: str
    description: Optional[str] = None
    mime_type: str = "text/plain"

    @abc.abstractmethod
    async def read(self) -> str:
        """Read the resource content."""
        return ""


class FunctionResource(Resource):
    """A resource that is generated by a function call.

    The function is called with kwargs parsed from the URI query string.
    For example, a URI of "fn://my_func?x=1&y=2" will call the function with
    kwargs {"x": "1", "y": "2"}.
    """

    func: Callable[..., Any]

    @field_validator("uri")
    @classmethod
    def validate_uri(cls, uri: str) -> str:
        """Ensure URI starts with fn://."""
        if not uri.startswith("fn://"):
            raise ValueError(f"URI must start with fn://: {uri}")
        return uri

    def _parse_uri_params(self) -> Dict[str, str]:
        """Parse URI query string into kwargs."""
        parsed = urlparse(self.uri)
        if not parsed.query:
            return {}
        # parse_qs returns Dict[str, List[str]], we want Dict[str, str]
        params = parse_qs(parsed.query)
        return {k: v[0] for k, v in params.items()}

    async def read(self) -> str:
        """Read the resource content by calling the function with URI params."""
        try:
            kwargs = self._parse_uri_params()
            result = await asyncio.to_thread(self.func, **kwargs)
            if isinstance(result, Resource):
                return await result.read()
            if isinstance(result, bytes):
                return result.decode()
            if not isinstance(result, str):
                return str(result)
            return result
        except Exception as e:
            raise ValueError(f"Error calling function {self.func.__name__}: {e}")


class FileResource(Resource):
    """A file resource."""

    path: Path

    @field_validator("path")
    @classmethod
    def validate_absolute_path(cls, path: Path) -> Path:
        """Ensure path is absolute."""
        if not path.is_absolute():
            raise ValueError(f"Path must be absolute: {path}")
        return path

    async def read(self) -> str:
        """Read the file content."""
        try:
            return await asyncio.to_thread(self.path.read_text)
        except FileNotFoundError:
            raise FileNotFoundError(f"File not found: {self.path}")
        except PermissionError:
            raise PermissionError(f"Permission denied: {self.path}")
        except Exception as e:
            raise ValueError(f"Error reading file {self.path}: {e}")


class HttpResource(Resource):
    """An HTTP resource."""

    url: str
    headers: Optional[Dict[str, str]] = None

    async def read(self) -> str:
        """Read the HTTP resource content."""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(self.url, headers=self.headers)
                response.raise_for_status()
                return response.text
        except httpx.HTTPStatusError as e:
            raise ValueError(f"HTTP error {e.response.status_code}: {e}")
        except httpx.RequestError as e:
            raise ValueError(f"Request failed: {e}")


class DirectoryResource(Resource):
    """A directory resource."""

    path: Path
    recursive: bool = False
    pattern: Optional[str] = None
    mime_type: str = "application/json"

    @field_validator("path")
    @classmethod
    def validate_absolute_path(cls, path: Path) -> Path:
        """Ensure path is absolute."""
        if not path.is_absolute():
            raise ValueError(f"Path must be absolute: {path}")
        return path

    def list_files(self) -> list[Path]:
        """List files in the directory."""
        if not self.path.exists():
            raise FileNotFoundError(f"Directory not found: {self.path}")
        if not self.path.is_dir():
            raise NotADirectoryError(f"Not a directory: {self.path}")

        try:
            if self.pattern:
                return (
                    list(self.path.glob(self.pattern))
                    if not self.recursive
                    else list(self.path.rglob(self.pattern))
                )
            return (
                list(self.path.glob("*"))
                if not self.recursive
                else list(self.path.rglob("*"))
            )
        except Exception as e:
            raise ValueError(f"Error listing directory {self.path}: {e}")

    async def read(self) -> str:
        """Read the directory listing."""
        try:
            files = await asyncio.to_thread(self.list_files)
            file_list = [str(f.relative_to(self.path)) for f in files if f.is_file()]
            return json.dumps({"files": file_list}, indent=2)
        except Exception as e:
            raise ValueError(f"Error reading directory {self.path}: {e}")


class ResourceManager:
    """Manages FlashMCP resources."""

    def __init__(self, warn_on_duplicate_resources: bool = True):
        self._resources: Dict[str, Resource] = {}
        self.warn_on_duplicate_resources = warn_on_duplicate_resources

    def get_resource(self, uri: str) -> Optional[Resource]:
        """Get resource by URI.

        First tries to find an exact match for the URI. If none is found,
        tries to match against any FunctionResources with wildcard patterns.
        """
        logger.debug("Getting resource", extra={"uri": uri})

        # First try exact match
        if resource := self._resources.get(uri):
            return resource

        # Then try pattern matching for FunctionResources
        for resource in self._resources.values():
            if isinstance(resource, FunctionResource) and hasattr(
                resource, "uri_regex"
            ):
                if resource.uri_regex.match(uri):
                    # Create a new instance with the actual URI
                    return FunctionResource(
                        uri=uri,  # Use actual URI
                        name=resource.name,
                        description=resource.description,
                        mime_type=resource.mime_type,
                        func=resource.func,
                    )

        raise ValueError(f"Unknown resource: {uri}")

    def list_resources(self) -> list[Resource]:
        """List all registered resources."""
        logger.debug("Listing resources", extra={"count": len(self._resources)})
        return list(self._resources.values())

    def add_resource(self, resource: Resource) -> Resource:
        """Add a resource to the manager.

        Args:
            resource: A Resource instance to add

        Returns:
            The added resource. If a resource with the same URI already exists,
            returns the existing resource.
        """
        logger.debug(
            "Adding resource",
            extra={
                "uri": resource.uri,
                "type": type(resource).__name__,
                "name": resource.name,
            },
        )
        existing = self._resources.get(resource.uri)
        if existing:
            if self.warn_on_duplicate_resources:
                warnings.warn(
                    f"Resource already exists: {resource.uri}",
                    ResourceWarning,
                    stacklevel=2,
                )
            return existing
        self._resources[resource.uri] = resource
        return resource
